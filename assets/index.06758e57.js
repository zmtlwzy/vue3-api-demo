import{_ as e}from"./index.15a0d8dd.js";import{e as a,ax as t,at as n,O as s,w as o,a2 as r,o as l,j as d,Q as c,i as f,ao as i,as as u}from"./vendor.3c431514.js";const p=a({name:"ShallowReactive",setup(){const e=t({foo:1,nested:{bar:2}});return e.foo++,console.log(n(e.nested)),e.nested.bar++,{}}}),v=c(" 创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换 (暴露原始值)。 "),m=f("br",null,null,-1),b=c(" 与 "),j=c("reactive"),_=c(" 不同，任何使用 "),g=c("ref"),w=c(" 的 property 都不会被代理自动解包。 ");var x=e(p,[["render",function(e,a,t,n,c,f){const p=i,x=u,R=r;return l(),s(R,{title:e.$options.name},{footer:o((()=>[d(x,{code:"\nconst state = shallowReactive({\n  foo: 1,\n  nested: {\n    bar: 2,\n  },\n});\n\n// 改变 state 本身的性质是响应式的\nstate.foo++;\n// ...但是不转换嵌套对象\nisReactive(state.nested); // false\nstate.nested.bar++; // 非响应式\n  ",language:"javascript"},null,8,["code"])])),default:o((()=>[v,m,b,d(p,null,{default:o((()=>[j])),_:1}),_,d(p,null,{default:o((()=>[g])),_:1}),w])),_:1},8,["title"])}]]);export{x as default};
