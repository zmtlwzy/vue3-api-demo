import{e,ab as a,a7 as n,o as t,h as o,j as s,i as r,J as l,a0 as d,a5 as u,T as f}from"./vendor.781c2143.js";var p=e({name:"ShallowReadonly",setup(){const e=a({foo:1,nested:{bar:2}});return e.foo++,n(e.nested),e.nested.bar++,{}}});const c=l(" 创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换 (暴露原始值)。"),i=r("br",null,null,-1),y=l(" 与 "),b=l("readonly"),m=l(" 不同，任何使用 "),h=l("ref"),j=l(" 的 property 都不会被代理自动解包。 ");p.render=function(e,a,n,l,p,v){const R=d,_=u,g=f;return t(),o(g,{title:e.$options.name},{footer:s((()=>[r(_,{code:"\nconst state = shallowReadonly({\n  foo: 1,\n  nested: {\n    bar: 2,\n  },\n});\n\n// 改变 state 本身的 property 将失败\nstate.foo++;\n// ...但适用于嵌套对象\nisReadonly(state.nested); // false\nstate.nested.bar++; // 适用\n  ",language:"javascript"},null,8,["code"])])),default:s((()=>[c,i,y,r(R,null,{default:s((()=>[b])),_:1}),m,r(R,null,{default:s((()=>[h])),_:1}),j])),_:1},8,["title"])};export default p;
