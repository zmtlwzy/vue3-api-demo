import{e,av as a,ar as t,o as n,L as s,n as o,m as r,O as l,i as d,am as f,aq as u,$ as c}from"./vendor.5b08720f.js";var i=e({name:"ShallowReactive",setup(){const e=a({foo:1,nested:{bar:2}});return e.foo++,console.log(t(e.nested)),e.nested.bar++,{}}});const p=l(" 创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换 (暴露原始值)。"),v=d("br",null,null,-1),b=l(" 与 "),m=l("reactive"),g=l(" 不同，任何使用 "),R=l("ref"),_=l(" 的 property 都不会被代理自动解包。 ");i.render=function(e,a,t,l,d,i){const h=f,j=u,w=c;return n(),s(w,{title:e.$options.name},{footer:o((()=>[r(j,{code:"\nconst state = shallowReactive({\n  foo: 1,\n  nested: {\n    bar: 2,\n  },\n});\n\n// 改变 state 本身的性质是响应式的\nstate.foo++;\n// ...但是不转换嵌套对象\nisReactive(state.nested); // false\nstate.nested.bar++; // 非响应式\n  ",language:"javascript"},null,8,["code"])])),default:o((()=>[p,v,b,r(h,null,{default:o((()=>[m])),_:1}),g,r(h,null,{default:o((()=>[R])),_:1}),_])),_:1},8,["title"])};export{i as default};
