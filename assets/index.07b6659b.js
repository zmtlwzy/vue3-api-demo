import{_ as a}from"./index.86834fdb.js";import{e,ay as n,au as t,O as s,w as o,a2 as r,o as l,j as d,Q as f,i as u,ao as p,as as c}from"./vendor.87a6fcc2.js";const i=e({name:"ShallowReadonly",setup(){const a=n({foo:1,nested:{bar:2}});return a.foo++,t(a.nested),a.nested.bar++,{}}}),y=f(" 创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换 (暴露原始值)。 "),b=u("br",null,null,-1),m=f(" 与 "),j=f("readonly"),_=f(" 不同，任何使用 "),v=f("ref"),w=f(" 的 property 都不会被代理自动解包。 ");var x=a(i,[["render",function(a,e,n,t,f,u){const i=p,x=c,R=r;return l(),s(R,{title:a.$options.name},{footer:o((()=>[d(x,{code:"\nconst state = shallowReadonly({\n  foo: 1,\n  nested: {\n    bar: 2,\n  },\n});\n\n// 改变 state 本身的 property 将失败\nstate.foo++;\n// ...但适用于嵌套对象\nisReadonly(state.nested); // false\nstate.nested.bar++; // 适用\n  ",language:"javascript"},null,8,["code"])])),default:o((()=>[y,b,m,d(i,null,{default:o((()=>[j])),_:1}),_,d(i,null,{default:o((()=>[v])),_:1}),w])),_:1},8,["title"])}]]);export{x as default};
